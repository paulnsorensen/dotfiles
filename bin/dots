#!/usr/bin/env bash
# Dotfiles management command
# Usage: dot [command] [args]

set -euo pipefail

# Allow override for testing, default to production path
DOTFILES_DIR="${DOTFILES_DIR:-${HOME}/Dev/dotfiles}"
DOTFILES_STATE_DIR="${DOTFILES_STATE_DIR:-${HOME}/.local/state/dotfiles}"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure we're in the dotfiles directory for git commands
cd_dotfiles() {
    cd "$DOTFILES_DIR" || {
        echo -e "${RED}Error: Cannot access dotfiles directory at $DOTFILES_DIR${NC}"
        exit 1
    }
}

# Show help
show_help() {
    echo -e "$(cat << EOF
${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}
${CYAN}â•‘       Dotfiles Management Tool         â•‘${NC}
${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}

${GREEN}Usage:${NC} dots [command] [args]

${BLUE}Commands:${NC}
  ${GREEN}update${NC}          Pull latest changes and run sync
  ${GREEN}sync${NC}            Run the sync script (with rollback support)
  ${GREEN}status${NC}          Show git status of dotfiles
  ${GREEN}rollback [id]${NC}   Rollback to a previous state
  ${GREEN}backups${NC}         List available backups
  ${GREEN}doctor${NC}          Run health checks and profile shell
  ${GREEN}test${NC}            Run test suite
  ${GREEN}help${NC}            Show this help message

${BLUE}Quick Actions:${NC}
  ${GREEN}dots${NC}            Show status (same as 'dots status')
  ${GREEN}dots u${NC}          Update (shorthand)
  ${GREEN}dots s${NC}          Sync (shorthand)
  ${GREEN}dots t${NC}          Test (shorthand)

${BLUE}Examples:${NC}
  dots update      # Pull changes and sync
  dots rollback    # Interactive rollback
  dots doctor      # Health checks + shell performance
  dots test        # Run test suite

EOF
)"
}

# Update dotfiles
do_update() {
    echo -e "${BLUE}ğŸ“¦ Updating dotfiles...${NC}"
    cd_dotfiles
    
    # Fetch changes
    git fetch || {
        echo -e "${RED}Failed to fetch updates${NC}"
        exit 1
    }
    
    # Check if we're behind
    LOCAL=$(git rev-parse HEAD)
    REMOTE=$(git rev-parse '@{u}')
    BASE=$(git merge-base HEAD '@{u}')
    
    if [[ "$LOCAL" == "$REMOTE" ]]; then
        echo -e "${GREEN}âœ… Already up to date!${NC}"
    elif [[ "$LOCAL" == "$BASE" ]]; then
        # Pull changes
        echo -e "${BLUE}Pulling changes...${NC}"
        git pull --rebase
        
        echo -e "${GREEN}âœ… Updated successfully!${NC}"
        echo
        echo -e "${BLUE}Running sync...${NC}"
        "$DOTFILES_DIR/.sync-with-rollback" || "$DOTFILES_DIR/.sync"
    else
        echo -e "${YELLOW}âš ï¸  Local changes detected${NC}"
        echo "Please commit or stash your changes first"
        git status -s
        exit 1
    fi
}

# Sync dotfiles
do_sync() {
    echo -e "${BLUE}ğŸ”„ Syncing dotfiles...${NC}"
    cd_dotfiles
    
    if [[ -f "$DOTFILES_DIR/.sync-with-rollback" ]]; then
        "$DOTFILES_DIR/.sync-with-rollback" "$@"
    else
        "$DOTFILES_DIR/.sync" "$@"
    fi
}

# Show status
do_status() {
    cd_dotfiles
    
    # Check for updates first
    git fetch --quiet 2>/dev/null || true
    
    LOCAL=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    REMOTE=$(git rev-parse '@{u}' 2>/dev/null || echo "unknown")
    
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘          Dotfiles Status               â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo
    
    # Branch info
    BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
    echo -e "${BLUE}Branch:${NC} $BRANCH"
    
    # Check if up to date
    if [[ "$LOCAL" != "unknown" ]] && [[ "$REMOTE" != "unknown" ]]; then
        if [[ "$LOCAL" == "$REMOTE" ]]; then
            echo -e "${GREEN}Status: âœ… Up to date${NC}"
        else
            BASE=$(git merge-base HEAD '@{u}' 2>/dev/null || echo "unknown")
            if [[ "$LOCAL" == "$BASE" ]]; then
                BEHIND=$(git rev-list --count 'HEAD..@{u}')
                echo -e "${YELLOW}Status: ğŸ“¦ $BEHIND commit(s) behind${NC}"
            elif [[ "$REMOTE" == "$BASE" ]]; then
                AHEAD=$(git rev-list --count '@{u}..HEAD')
                echo -e "${BLUE}Status: ğŸ“¤ $AHEAD commit(s) ahead${NC}"
            else
                echo -e "${YELLOW}Status: âš ï¸  Diverged${NC}"
            fi
        fi
    fi
    
    echo
    
    # Git status
    if [[ -n "$(git status -s 2>/dev/null)" ]]; then
        echo -e "${YELLOW}Uncommitted changes:${NC}"
        git status -s
    else
        echo -e "${GREEN}Working directory clean${NC}"
    fi
    
    # Last sync info
    if [[ -f "$DOTFILES_STATE_DIR/last_sync" ]]; then
        LAST_SYNC=$(cat "$DOTFILES_STATE_DIR/last_sync")
        LAST_SYNC_DATE=$(date -r "$LAST_SYNC" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "unknown")
        echo
        echo -e "${BLUE}Last sync:${NC} $LAST_SYNC_DATE"
    fi
}

# Run health checks
do_doctor() {
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘         Dotfiles Health Check          â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo

    local issues=0

    # Check for broken symlinks
    echo -e "${BLUE}Checking symlinks...${NC}"
    local broken_links=0
    while IFS= read -r link; do
        if [[ ! -e "$link" ]]; then
            echo -e "  ${RED}âœ— Broken: $link${NC}"
            broken_links=$((broken_links + 1))
            issues=$((issues + 1))
        fi
    done < <(find "$HOME" -maxdepth 2 -type l 2>/dev/null)

    if [[ $broken_links -eq 0 ]]; then
        echo -e "  ${GREEN}âœ“ All symlinks valid${NC}"
    fi

    # Check git hooks
    echo -e "${BLUE}Checking git hooks...${NC}"
    if [[ "$(git config core.hooksPath)" == *"githooks"* ]]; then
        echo -e "  ${GREEN}âœ“ Git hooks installed${NC}"
    else
        echo -e "  ${YELLOW}âš  Git hooks not installed${NC}"
        echo -e "    Run: ${GREEN}./githooks/install-hooks.sh${NC}"
        issues=$((issues + 1))
    fi

    # Check for required commands
    echo -e "${BLUE}Checking dependencies...${NC}"
    local missing_deps=()
    for cmd in git zsh curl; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
            issues=$((issues + 1))
        fi
    done

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        echo -e "  ${GREEN}âœ“ All required commands found${NC}"
    else
        echo -e "  ${RED}âœ— Missing: ${missing_deps[*]}${NC}"
    fi

    # Check VS Code settings if they exist
    if [[ -d "$DOTFILES_DIR/vscode" ]]; then
        echo -e "${BLUE}Checking VS Code configuration...${NC}"
        if [[ -L "$HOME/Library/Application Support/Code/User/settings.json" ]]; then
            echo -e "  ${GREEN}âœ“ VS Code settings symlinked${NC}"
        else
            echo -e "  ${YELLOW}âš  VS Code settings not symlinked${NC}"
            echo -e "    Run: ${GREEN}cd $DOTFILES_DIR/vscode && ./.sync${NC}"
        fi
    fi

    # Profile shell startup
    echo -e "${BLUE}Profiling shell startup...${NC}"
    local times=()
    for _ in {1..3}; do
        local start
        start=$(date +%s%N 2>/dev/null || date +%s000000000)
        zsh -i -c exit 2>/dev/null || true
        local end
        end=$(date +%s%N 2>/dev/null || date +%s000000000)
        local duration=$(( (end - start) / 1000000 ))
        times+=("$duration")
    done

    # Calculate average
    local sum=0
    for time in "${times[@]}"; do
        sum=$((sum + time))
    done
    local avg=$((sum / 3))

    if [[ $avg -lt 200 ]]; then
        echo -e "  ${GREEN}âœ“ Shell startup: ${avg}ms (fast)${NC}"
    elif [[ $avg -lt 500 ]]; then
        echo -e "  ${YELLOW}âš  Shell startup: ${avg}ms (moderate)${NC}"
    else
        echo -e "  ${RED}âœ— Shell startup: ${avg}ms (slow)${NC}"
        echo -e "    Run ${GREEN}DOTFILES_PROFILE=1 zsh${NC} for detailed profiling"
        issues=$((issues + 1))
    fi

    # Summary
    echo
    if [[ $issues -eq 0 ]]; then
        echo -e "${GREEN}â•â•â• All checks passed! â•â•â•${NC}"
    else
        echo -e "${YELLOW}â•â•â• Found $issues issue(s) â•â•â•${NC}"
    fi
}

# Main command handler
case "${1:-status}" in
    update|u)
        do_update
        ;;
    sync|s)
        shift
        do_sync "$@"
        ;;
    status|st)
        do_status
        ;;
    rollback|rb)
        shift
        "$DOTFILES_DIR/.sync-with-rollback" rollback "$@"
        ;;
    backups|b)
        "$DOTFILES_DIR/.sync-with-rollback" list-backups
        ;;
    doctor|d)
        do_doctor
        ;;
    test|t)
        shift
        if [[ -f "$DOTFILES_DIR/tests/run-tests.sh" ]]; then
            "$DOTFILES_DIR/tests/run-tests.sh" "$@"
        else
            echo -e "${RED}Test suite not found${NC}"
            echo "Tests are located in: $DOTFILES_DIR/tests/"
            exit 1
        fi
        ;;
    help|h|--help|-h)
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo
        show_help
        exit 1
        ;;
esac