#!/usr/bin/env bash
# Pre-commit hook to prevent committing secrets and validate scripts

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

ERRORS=0

echo "üîç Running pre-commit checks..."

# Check for potential secrets
echo "Checking for secrets..."

# Patterns that might indicate secrets
SECRET_PATTERNS=(
    "password.*=.*['\"][^'\"]{3,}['\"]"
    "token.*=.*['\"][^'\"]{10,}['\"]"
    "secret.*=.*['\"][^'\"]{3,}['\"]"
    "api[_-]?key.*=.*['\"][^'\"]{10,}['\"]"
    "private[_-]?key.*=.*['\"][^'\"]{10,}['\"]"
    "access[_-]?key.*=.*['\"][^'\"]{10,}['\"]"
    "client[_-]?secret.*=.*['\"][^'\"]{10,}['\"]"
    "auth.*=.*['\"][^'\"]{3,}['\"]"
    "BRAVE_API_KEY=[^'\"]{10,}"  # Specific to your config
)

# Files to check (staged files only)
FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [[ -n "$FILES" ]]; then
    for pattern in "${SECRET_PATTERNS[@]}"; do
        # Check each staged file for the pattern
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                # Skip .example files and this hook file
                if [[ "$file" == *.example ]] || [[ "$file" == *githooks* ]] || [[ "$file" == tests/* ]]; then
                    continue
                fi
                
                # Check for pattern (case insensitive)
                if grep -iE "$pattern" "$file" >/dev/null 2>&1; then
                    echo -e "${RED}‚ùå Potential secret found in $file${NC}"
                    echo "   Pattern: $pattern"
                    grep -inE "$pattern" "$file" | head -3
                    ERRORS=$((ERRORS + 1))
                fi
            fi
        done <<< "$FILES"
    done
fi

# Check for common secret file patterns
echo "Checking for secret files..."
SECRET_FILES=(
    ".env"
    ".env.local"
    ".env.production"
    "secrets.yml"
    "secrets.yaml"
    "credentials"
    "id_rsa"
    "id_ed25519"
    ".pem"
    ".key"
    ".p12"
)

for file in $FILES; do
    filename=$(basename "$file")
    for secret_file in "${SECRET_FILES[@]}"; do
        if [[ "$filename" == "$secret_file" ]] || [[ "$filename" == *"$secret_file" ]]; then
            if [[ "$filename" != *.example ]] && [[ "$filename" != *.sample ]]; then
                echo -e "${RED}‚ùå Secret file detected: $file${NC}"
                echo "   Use .example or .sample suffix for templates"
                ERRORS=$((ERRORS + 1))
            fi
        fi
    done
done

# Validate shell scripts
echo "Validating shell scripts..."
for file in $FILES; do
    if [[ "$file" == *.sh ]] || [[ "$file" == *.bash ]]; then
        if ! bash -n "$file" 2>/dev/null; then
            echo -e "${RED}‚ùå Syntax error in $file${NC}"
            bash -n "$file" 2>&1 | head -5
            ERRORS=$((ERRORS + 1))
        else
            echo -e "${GREEN}‚úì $file syntax OK${NC}"
        fi
    elif [[ "$file" == *.zsh ]]; then
        # Check zsh files with zsh if available, otherwise skip
        if command -v zsh >/dev/null 2>&1; then
            if ! zsh -n "$file" 2>/dev/null; then
                echo -e "${RED}‚ùå Syntax error in $file${NC}"
                zsh -n "$file" 2>&1 | head -5
                ERRORS=$((ERRORS + 1))
            else
                echo -e "${GREEN}‚úì $file syntax OK${NC}"
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Skipping $file (zsh not available)${NC}"
        fi
    fi
    
    # Check for files with shell shebang
    if [[ -f "$file" ]] && head -1 "$file" | grep -q "^#!/.*bash\|^#!/.*sh"; then
        if ! bash -n "$file" 2>/dev/null; then
            echo -e "${RED}‚ùå Syntax error in $file${NC}"
            bash -n "$file" 2>&1 | head -5
            ERRORS=$((ERRORS + 1))
        fi
    elif [[ -f "$file" ]] && head -1 "$file" | grep -q "^#!/.*zsh"; then
        if command -v zsh >/dev/null 2>&1; then
            if ! zsh -n "$file" 2>/dev/null; then
                echo -e "${RED}‚ùå Syntax error in $file${NC}"
                zsh -n "$file" 2>&1 | head -5
                ERRORS=$((ERRORS + 1))
            fi
        fi
    fi
done

# Run shellcheck on staged shell scripts
if command -v shellcheck >/dev/null 2>&1; then
    echo "Running shellcheck..."
    for file in $FILES; do
        if [[ -f "$file" ]] && { [[ "$file" == *.sh ]] || [[ "$file" == *.bash ]] || head -1 "$file" 2>/dev/null | grep -q "^#!/.*bash\|^#!/.*sh"; }; then
            if ! shellcheck "$file" 2>/dev/null; then
                echo -e "${RED}‚ùå shellcheck issues in $file${NC}"
                ERRORS=$((ERRORS + 1))
            fi
        fi
    done
else
    echo -e "${YELLOW}‚ö† shellcheck not installed, skipping${NC}"
fi

# Check for large files
echo "Checking file sizes..."
for file in $FILES; do
    if [[ -f "$file" ]]; then
        size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
        # Warn if file is larger than 1MB
        if [[ $size -gt 1048576 ]]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Large file: $file ($((size / 1024))KB)${NC}"
            read -p "Are you sure you want to commit this large file? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                ERRORS=$((ERRORS + 1))
            fi
        fi
    fi
done

# Check for debugging statements
echo "Checking for debug statements..."
DEBUG_PATTERNS=(
    "console\.log"
    "print\("
    "var_dump"
    "dd\("
    "debugger"
    "binding\.pry"
    "import pdb"
    "pdb\.set_trace"
)

for pattern in "${DEBUG_PATTERNS[@]}"; do
    for file in $FILES; do
        # Skip test files and this hook
        if [[ "$file" == *test* ]] || [[ "$file" == *spec* ]] || [[ "$file" == *githooks* ]]; then
            continue
        fi
        
        if [[ -f "$file" ]] && grep -q "$pattern" "$file" 2>/dev/null; then
            echo -e "${YELLOW}‚ö†Ô∏è  Debug statement found in $file${NC}"
            grep -n "$pattern" "$file" | head -2
        fi
    done
done

# Final result
echo
if [[ $ERRORS -gt 0 ]]; then
    echo -e "${RED}‚ùå Pre-commit checks failed with $ERRORS error(s)${NC}"
    echo
    echo "To bypass these checks (NOT RECOMMENDED), use:"
    echo "  git commit --no-verify"
    echo
    echo "To fix:"
    echo "  1. Remove or mask secrets (use .env.example for templates)"
    echo "  2. Fix shell script syntax errors"
    echo "  3. Consider using git-crypt or git-secret for sensitive files"
    exit 1
else
    echo -e "${GREEN}‚úÖ All pre-commit checks passed!${NC}"
fi